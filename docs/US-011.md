Да, давай “актуализируем” словарь правильно: **скриптом**, который прогоняется локально (или в CI) и обновляет `public/translations.v1.json`. В рантайме (в браузере) ключа не будет — это принципиально важно для безопасности.

DeepL официально использует endpoint **`/translate`** и для API Free нужно обращаться к **`https://api-free.deepl.com`**. Авторизация — через `DeepL-Auth-Key`. ([DeepL Documentation][1])

Ниже — точные шаги, что добавить в проект.

---

# 1) Куда положить ключ (env файл на диске проекта)

Создай файл **`.env.local`** в корне репозитория (рядом с `package.json`):

```bash
touch .env.local
```

Добавь туда:

```env
DEEPL_AUTH_KEY=your_key_here
DEEPL_API_BASE=https://api-free.deepl.com
```

И обязательно добавь в `.gitignore`:

```gitignore
.env.local
tools/cache/
```

DeepL API Free даёт лимит 500,000 символов в месяц, поэтому мы будем экономить запросы и использовать кэш. ([support.deepl.com][2])

---

# 2) Что именно дописать в “старую” story

US-010 у тебя закрыта (FreeDict RU + bundle).
То, что ты сейчас хочешь — это **новая история US-011: Dictionary refresh via DeepL**, и её нужно добавить в docs (это не “дописать в 10-ю”, а расширение пайплайна).

Но технически она будет **работать поверх** твоего текущего `translations.v1.json`:

* FreeDict RU остаётся базой
* DeepL заполняет только **missing RU** (или позже: “плохие” записи)

---

# 3) Скрипт US-011: enrich missing RU через DeepL

Создай файл: `scripts/dict-refresh-ru.mjs`

```js
#!/usr/bin/env node
/**
 * Enrich missing RU translations in public/translations.v1.json using DeepL API.
 * Runs locally/CI only. Never used from browser runtime.
 *
 * Requirements:
 * - Node 18+ (global fetch)
 * - .env.local with DEEPL_AUTH_KEY and optional DEEPL_API_BASE
 */

import fs from "node:fs";
import path from "node:path";
import process from "node:process";

function loadEnvLocal() {
  // Minimal .env loader to avoid adding dependencies.
  const p = path.resolve(process.cwd(), ".env.local");
  if (!fs.existsSync(p)) return;
  const content = fs.readFileSync(p, "utf8");
  for (const line of content.split(/\r?\n/)) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const idx = trimmed.indexOf("=");
    if (idx <= 0) continue;
    const k = trimmed.slice(0, idx).trim();
    const v = trimmed.slice(idx + 1).trim();
    if (!process.env[k]) process.env[k] = v;
  }
}

function readLines(filePath) {
  const raw = fs.readFileSync(filePath, "utf8");
  return raw
    .split(/\r?\n/)
    .map((s) => s.trim())
    .filter(Boolean);
}

function normalizeWord(w) {
  return w.toLowerCase();
}

function isAsciiWord(w) {
  return /^[a-z]+$/.test(w);
}

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function loadJson(filePath) {
  return JSON.parse(fs.readFileSync(filePath, "utf8"));
}

function saveJson(filePath, obj) {
  fs.writeFileSync(filePath, JSON.stringify(obj, null, 2) + "\n", "utf8");
}

function pickFirstTranslation(text) {
  // Pragmatic cleanup: take first line, then split by common separators.
  const firstLine = String(text).split(/\r?\n/)[0].trim();
  const first =
    firstLine.split(";")[0].split(" / ")[0].split(" | ")[0].trim();
  return first || "—";
}

async function deeplTranslateBatch({ apiBase, authKey, texts, targetLang }) {
  // DeepL docs: /translate endpoint; accepts form-encoded or JSON bodies. :contentReference[oaicite:2]{index=2}
  // We'll use JSON to keep things simple.
  const url = `${apiBase.replace(/\/$/, "")}/v2/translate`;
  const body = {
    text: texts,
    source_lang: "EN",
    target_lang: targetLang, // "RU"
  };

  const res = await fetch(url, {
    method: "POST",
    headers: {
      "Authorization": `DeepL-Auth-Key ${authKey}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(body),
  });

  if (!res.ok) {
    const msg = await res.text().catch(() => "");
    throw new Error(`DeepL HTTP ${res.status}: ${msg.slice(0, 400)}`);
  }

  const json = await res.json();
  // Expected: { translations: [{ text: "..." }, ...] } in same order. :contentReference[oaicite:3]{index=3}
  return json.translations.map((t) => t.text);
}

async function main() {
  loadEnvLocal();

  const authKey = process.env.DEEPL_AUTH_KEY;
  const apiBase = process.env.DEEPL_API_BASE || "https://api-free.deepl.com";
  if (!authKey) {
    console.error("Missing DEEPL_AUTH_KEY. Put it in .env.local (not committed).");
    process.exit(2);
  }

  const wordListPath = path.resolve("src/data/raw/google-10000-english.txt");
  const bundlePath = path.resolve("public/translations.v1.json");
  const cacheDir = path.resolve("tools/cache");
  const cachePath = path.resolve(cacheDir, "deepl-ru-cache.json");

  if (!fs.existsSync(wordListPath)) throw new Error(`Word list not found: ${wordListPath}`);
  if (!fs.existsSync(bundlePath)) throw new Error(`Bundle not found: ${bundlePath}`);

  const words = readLines(wordListPath)
    .map(normalizeWord)
    .filter(isAsciiWord);

  const bundle = loadJson(bundlePath);
  bundle.data ||= {};

  ensureDir(cacheDir);
  const cache = fs.existsSync(cachePath) ? loadJson(cachePath) : {};

  // Determine missing RU entries.
  const missing = [];
  for (const w of words) {
    const existing = bundle.data[w]?.ru;
    const cached = cache[w];
    if (existing && existing !== "—") continue;
    if (cached && cached !== "—") continue;
    missing.push(w);
  }

  const existingCount = words.filter((w) => bundle.data[w]?.ru && bundle.data[w].ru !== "—").length;
  console.log(`Before: RU coverage ${existingCount}/${words.length} (${(existingCount/words.length*100).toFixed(2)}%)`);
  console.log(`Missing for DeepL: ${missing.length}`);

  if (missing.length === 0) {
    console.log("Nothing to enrich. Exiting.");
    process.exit(0);
  }

  const BATCH_SIZE = 40; // keep request size well below 128 KiB limit. :contentReference[oaicite:4]{index=4}
  for (let i = 0; i < missing.length; i += BATCH_SIZE) {
    const batch = missing.slice(i, i + BATCH_SIZE);
    // Translate as plain words; we accept that some may be ambiguous.
    const translations = await deeplTranslateBatch({
      apiBase,
      authKey,
      texts: batch,
      targetLang: "RU",
    });

    for (let j = 0; j < batch.length; j++) {
      const w = batch[j];
      const ruRaw = translations[j];
      const ru = pickFirstTranslation(ruRaw);
      cache[w] = ru;
      // Merge into bundle (but do not overwrite a non-placeholder RU already present).
      bundle.data[w] ||= {};
      if (!bundle.data[w].ru || bundle.data[w].ru === "—") {
        bundle.data[w].ru = ru;
      }
    }

    saveJson(cachePath, cache);
    console.log(`Enriched ${Math.min(i + BATCH_SIZE, missing.length)}/${missing.length}`);
    // Optional gentle throttling; remove if you want max speed.
    await new Promise((r) => setTimeout(r, 250));
  }

  bundle.generatedAt = new Date().toISOString();
  // Keep langs accurate:
  const langs = new Set(bundle.langs || []);
  langs.add("ru");
  bundle.langs = Array.from(langs);

  saveJson(bundlePath, bundle);

  const afterCount = words.filter((w) => bundle.data[w]?.ru && bundle.data[w].ru !== "—").length;
  console.log(`After: RU coverage ${afterCount}/${words.length} (${(afterCount/words.length*100).toFixed(2)}%)`);
  console.log(`Cache: ${cachePath}`);
  console.log(`Bundle updated: ${bundlePath}`);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
```

---

# 4) Добавить npm script

В `package.json`:

```json
{
  "scripts": {
    "dict:refresh:ru": "node scripts/dict-refresh-ru.mjs"
  }
}
```

---

# 5) Как запускать

1. Положил ключ в `.env.local`
2. Выполни:

```bash
npm run dict:refresh:ru
```

После этого:

* обновится `public/translations.v1.json`
* появится/обновится `tools/cache/deepl-ru-cache.json` (не коммитить)

---

# 6) Ответ на ваш вопрос “Надо в старую дописать, или ты дописал?”

Я не мог физически дописать в ваш репозиторий, но выше я дал **полный готовый артефакт** для US-011: куда положить ключ, какой файл создать, какие команды добавить.

В документации:

* US-010 остаётся “FreeDict RU base bundle”
* US-011 добавляем как “Dictionary актуализация/обогащение через DeepL (missing only)”

Если хотите — в следующем сообщении дам текст для вставки в `docs/USER_STORIES.md` и `docs/OPERATIONS.md` (коротко и в вашем стиле).

Важно: в DeepL API Free лимит 500k символов/месяц, а 4510 слов по ~10 символов — это примерно 45–60k символов, то есть в лимит обычно укладывается. ([support.deepl.com][2])

[1]: https://developers.deepl.com/docs/getting-started/your-first-api-request?utm_source=chatgpt.com "Your first API request - DeepL Documentation"
[2]: https://support.deepl.com/hc/en-us/articles/360021200939-DeepL-API-plans?utm_source=chatgpt.com "DeepL API plans"
